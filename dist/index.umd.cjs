(function(o,f){typeof exports=="object"&&typeof module<"u"?f(exports,require("react")):typeof define=="function"&&define.amd?define(["exports","react"],f):(o=typeof globalThis<"u"?globalThis:o||self,f(o.index={},o.react))})(this,function(o,f){"use strict";var L=Object.defineProperty;var T=(o,f,u)=>f in o?L(o,f,{enumerable:!0,configurable:!0,writable:!0,value:u}):o[f]=u;var g=(o,f,u)=>T(o,typeof f!="symbol"?f+"":f,u);const u=e=>typeof e=="object"&&e!==null&&!Array.isArray(e)&&e.constructor===Object,p=(e,t)=>{if(e===null&&t===null)return!0;if(e===null||t===null||typeof e!=typeof t)return!1;if(typeof e!="object")return e===t;if(Array.isArray(e)&&Array.isArray(t))return e.length!==t.length?!1:e.every((r,c)=>p(r,t[c]));const n=Object.keys(e),s=Object.keys(t);return n.length!==s.length?!1:n.every(r=>s.includes(r)?p(e[r],t[r]):!1)},E=e=>e instanceof Function&&typeof e=="function",l=class l{constructor(){g(this,"listeners",{});g(this,"notifierState",{});g(this,"actionSet",{})}static getInstance(){return l.instance||(l.instance=new l),l.instance}validateEvent(t){return!!(t&&typeof t=="string")}notify(t,n,s,r=!1,c="notifier_default"){if(!this.validateEvent(t))throw new Error(`Invalid event name: '${t}'`);if(!this.listeners[t]){console.warn(`No listeners for event: '${t}' called by '${c}'.`);return}const a=this.listeners[t][s];if(!a){console.warn(`No listeners found for slice: '${s}' of event: '${t}' called by '${c}'.`);return}const S=this.notifierState[t][s],d=u(n)?{...S||{},...n}:n;p(S,d)?console.warn("notify rejected as the previous state and current state are same."):(this.notifierState[t][s]=d,a.forEach(i=>i(d,this.getActionSet(),S,r)))}listen(t,n,s={},r){if(!this.validateEvent(t)||!E(n))throw new Error(`Invalid parameters for event: '${t}'`);(!this.listeners[t]||!this.notifierState[t])&&(this.listeners[t]={},this.notifierState[t]={}),this.listeners[t][r]||(this.listeners[t][r]=new Set,this.notifierState[t][r]=s),this.listeners[t][r].add(n)}unsubscribe(t,n,s){if(!this.validateEvent(t)||!this.listeners[t])throw new Error(`No listeners found for event: '${t}' to unsubscribe.`);const r=this.listeners[t][s];(!r||!r.delete(n))&&console.warn(`Cannot unsubscribe to a non-existent listener '${t}'.`)}getState(t,n){var s;return n?(s=this.notifierState[t])==null?void 0:s[n]:this.notifierState[t]}registerAction(t,n){this.actionSet[n]||(this.actionSet[n]=new Set),this.actionSet[n].add(t)}unregisterAction(t,n){this.actionSet[n]&&(this.actionSet[n].delete(t),this.actionSet[n].size===0&&delete this.actionSet[n])}getActionSet(){return this.actionSet}};g(l,"instance");let b=l;const I=(e,t,n)=>{const s=n||`${e.toLowerCase()}_global`,r=b.getInstance(),c=r.getState(e,s),a=(i,h,y,w)=>{var j;const $=!p(i,y);!w&&$?(j=h[s])!=null&&j.size&&h[s].forEach(A=>{A&&A(typeof i=="object"&&i!==null?x=>({...x,...i}):i)}):$?w&&console.log("Updated store transiently"):console.warn("State update dismissed: previous and current state are same.")};r.listen(e,a,c||t,s);const S=i=>u(i)?new Proxy(i,{get:(h,y)=>r.getState(e,s)[y]}):r.getState(e,s);return{useStore:()=>{const[i,h]=f.useState(t);return f.useEffect(()=>(r.registerAction(h,s),()=>{r.unregisterAction(h,s)}),[]),[S(i),y=>{r.notify(e,y,s,!1,"create")}]},set:i=>{r.notify(e,i,s,!1,"create_set")},setTransient:i=>{r.notify(e,i,s,!0,"create_transient")},getStoreSnapshot:()=>r.getState(e,s),subscribe:i=>{r.listen(e,i,t,s)}}},O=(e,t,n,s=!1,r="notifier_global")=>{const c=b.getInstance(),a=n||`${e.toLowerCase()}_global`;c.notify(e,t,a,s,r)};o.create=I,o.notify=O,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
